{"ast":null,"code":"import React, { useRef } from 'react'; // vector add\n\nfunction addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n} // vector substract\n\n\nfunction subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\n\nfunction calculateAllGeometry(movement, delta) {\n  if (delta === void 0) {\n    delta = movement;\n  }\n\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\n\nfunction calculateAllKinematics(movement, delta, dt) {\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var beta = dt === 0 ? 0 : 1 / dt;\n  var velocity = beta * dl;\n  var velocities = delta.map(function (v) {\n    return beta * v;\n  });\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    velocities: velocities,\n    velocity: velocity,\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\r\n * This polyfill function is suggested by Mozilla:\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\r\n * @param x target number\r\n */\n\n\nfunction sign(x) {\n  if (Math.sign) return Math.sign(x);\n  return Number(x > 0) - Number(x < 0) || +x;\n}\n\nfunction minMax(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\n\n\nfunction rubberband2(distance, constant) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5);\n}\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n  if (constant === void 0) {\n    constant = 0.15;\n  }\n\n  if (constant === 0) return minMax(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction noop() {}\n/**\r\n * TODO Beware that only optimized cases are covered in tests =)\r\n * TODO Need to cover general case as well\r\n *\r\n * @param fns\r\n */\n\n\nfunction chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    var result;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {\n      var fn = _step.value;\n      result = fn.apply(this, arguments) || result;\n    }\n\n    return result;\n  };\n}\n/**\r\n * Expects a simple value or 2D vector (an array with 2 elements) and\r\n * always returns 2D vector. If simple value is passed, returns a\r\n * vector with this value as both coordinates.\r\n *\r\n * @param value\r\n */\n\n\nfunction ensureVector(value, fallback) {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected');\n    }\n\n    value = fallback;\n  }\n\n  if (Array.isArray(value)) return value;\n  return [value, value];\n}\n/**\r\n * Helper for defining a default value\r\n *\r\n * @param value\r\n * @param fallback\r\n */\n\n\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n/**\r\n * Resolves getters (functions) by calling them\r\n * If simple value is given it just passes through\r\n *\r\n * @param v\r\n */\n\n\nfunction valueFn(v) {\n  if (typeof v === 'function') {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    } // @ts-ignore\n\n\n    return v.apply(void 0, args);\n  } else {\n    return v;\n  }\n}\n\nfunction resolveWith(config, resolvers) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var result = {};\n\n  for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _Object$entries[_i],\n        key = _Object$entries$_i[0],\n        resolver = _Object$entries$_i[1];\n\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config);\n        break;\n\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n\n  return result;\n}\n\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\nfunction supportsGestureEvents() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction supportsTouchEvents() {\n  return typeof window !== 'undefined' && 'ontouchstart' in window;\n}\n\nfunction getEventTouches(event) {\n  if ('pointerId' in event) return null;\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches;\n}\n\nfunction getPointerIds(event) {\n  if ('pointerId' in event) return [event.pointerId];\n  return Array.from(getEventTouches(event)).map(function (t) {\n    return t.identifier;\n  });\n}\n\nfunction getGenericEventData(event) {\n  var buttons = 'buttons' in event ? event.buttons : 0;\n  var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey; // TODO check if this might create some overrides?\n\n  return {\n    buttons: buttons,\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n\nvar identity = function identity(xy) {\n  return xy;\n};\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */\n\n\nfunction getPointerEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n\n  var touchEvents = getEventTouches(event);\n\n  var _ref = touchEvents ? touchEvents[0] : event,\n      clientX = _ref.clientX,\n      clientY = _ref.clientY;\n\n  return transform([clientX, clientY]);\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\n\nfunction getTwoTouchesEventValues(event, pointerIds, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n\n  var _Array$from$filter = Array.from(event.touches).filter(function (t) {\n    return pointerIds.includes(t.identifier);\n  }),\n      A = _Array$from$filter[0],\n      B = _Array$from$filter[1];\n\n  var dx = B.clientX - A.clientX;\n  var dy = B.clientY - A.clientY;\n  var cx = (B.clientX + A.clientX) / 2;\n  var cy = (B.clientY + A.clientY) / 2; // const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  var distance = Math.hypot(dx, dy); // FIXME rotation has inconsistant values so we're not using it atm\n  // const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n\n  var angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  var values = transform([distance, angle]);\n  var origin = transform([cx, cy]);\n  return {\n    values: values,\n    origin: origin\n  };\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */\n\n\nfunction getScrollEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  } // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n\n\n  var _event$currentTarget = event.currentTarget,\n      scrollX = _event$currentTarget.scrollX,\n      scrollY = _event$currentTarget.scrollY,\n      scrollLeft = _event$currentTarget.scrollLeft,\n      scrollTop = _event$currentTarget.scrollTop;\n  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0]);\n} // wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\n\n\nvar LINE_HEIGHT = 40;\nvar PAGE_HEIGHT = 800;\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */\n\nfunction getWheelEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY,\n      deltaMode = event.deltaMode; // normalize wheel values, especially for Firefox\n\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n\n  return transform([deltaX, deltaY]);\n}\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */\n\n\nfunction getWebkitGestureEventValues(event, transform) {\n  if (transform === void 0) {\n    transform = identity;\n  }\n\n  return transform([event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation]);\n}\n\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 60;\nvar InternalGestureOptionsNormalizers = {\n  threshold: function threshold(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    return ensureVector(value);\n  },\n  rubberband: function rubberband(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND);\n\n      case false:\n        return ensureVector(0);\n\n      default:\n        return ensureVector(value);\n    }\n  },\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n\n    return value;\n  },\n  triggerAllEvents: function triggerAllEvents(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value;\n  },\n  initial: function initial(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    if (typeof value === 'function') return value;\n    return ensureVector(value);\n  },\n  transform: true\n};\n\nvar InternalCoordinatesOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  axis: true,\n  lockDirection: function lockDirection(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value;\n  },\n  bounds: function bounds(value) {\n    if (value === void 0) {\n      value = {};\n    }\n\n    if (typeof value === 'function') return function (state) {\n      return InternalCoordinatesOptionsNormalizers.bounds(value(state));\n    };\n    var _value2 = value,\n        _value2$left = _value2.left,\n        left = _value2$left === void 0 ? -Infinity : _value2$left,\n        _value2$right = _value2.right,\n        right = _value2$right === void 0 ? Infinity : _value2$right,\n        _value2$top = _value2.top,\n        top = _value2$top === void 0 ? -Infinity : _value2$top,\n        _value2$bottom = _value2.bottom,\n        bottom = _value2$bottom === void 0 ? Infinity : _value2$bottom;\n    return [[left, right], [top, bottom]];\n  }\n});\n\nvar isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nvar InternalGenericOptionsNormalizers = {\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n\n    return value;\n  },\n  domTarget: true,\n  window: /*#__PURE__*/function (_window) {\n    function window(_x) {\n      return _window.apply(this, arguments);\n    }\n\n    window.toString = function () {\n      return _window.toString();\n    };\n\n    return window;\n  }(function (value) {\n    if (value === void 0) {\n      value = isBrowser ? window : undefined;\n    }\n\n    return value;\n  }),\n  eventOptions: function eventOptions(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$passive = _ref.passive,\n        passive = _ref$passive === void 0 ? true : _ref$passive,\n        _ref$capture = _ref.capture,\n        capture = _ref$capture === void 0 ? false : _ref$capture;\n\n    return {\n      passive: passive,\n      capture: capture\n    };\n  },\n  transform: true\n};\n\nvar InternalDistanceAngleOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  bounds: function bounds(_value, _key, _ref2) {\n    var _ref2$distanceBounds = _ref2.distanceBounds,\n        distanceBounds = _ref2$distanceBounds === void 0 ? {} : _ref2$distanceBounds,\n        _ref2$angleBounds = _ref2.angleBounds,\n        angleBounds = _ref2$angleBounds === void 0 ? {} : _ref2$angleBounds;\n\n    var _distanceBounds = function _distanceBounds(state) {\n      var D = assignDefault(valueFn(distanceBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    var _angleBounds = function _angleBounds(state) {\n      var A = assignDefault(valueFn(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function') return [_distanceBounds(), _angleBounds()];\n    return function (state) {\n      return [_distanceBounds(state), _angleBounds(state)];\n    };\n  }\n});\n\nvar InternalDragOptionsNormalizers = /*#__PURE__*/_extends({}, InternalCoordinatesOptionsNormalizers, {\n  useTouch: function useTouch(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value && supportsTouchEvents();\n  },\n  experimental_preventWindowScrollY: function experimental_preventWindowScrollY(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value;\n  },\n  threshold: function threshold(v, _k, _ref3) {\n    var _ref3$filterTaps = _ref3.filterTaps,\n        filterTaps = _ref3$filterTaps === void 0 ? false : _ref3$filterTaps,\n        _ref3$lockDirection = _ref3.lockDirection,\n        lockDirection = _ref3$lockDirection === void 0 ? false : _ref3$lockDirection,\n        _ref3$axis = _ref3.axis,\n        axis = _ref3$axis === void 0 ? undefined : _ref3$axis;\n    var A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    return A;\n  },\n  swipeVelocity: function swipeVelocity(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_VELOCITY;\n    }\n\n    return ensureVector(v);\n  },\n  swipeDistance: function swipeDistance(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_DISTANCE;\n    }\n\n    return ensureVector(v);\n  },\n  delay: function delay(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  }\n});\n\nfunction getInternalGenericOptions(config) {\n  if (config === void 0) {\n    config = {};\n  } // TODO warn when passive is set to true and domTarget is undefined\n\n\n  return resolveWith(config, InternalGenericOptionsNormalizers);\n}\n\nfunction getInternalCoordinatesOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalCoordinatesOptionsNormalizers);\n}\n\nfunction getInternalDistanceAngleOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalDistanceAngleOptionsNormalizers);\n}\n\nfunction getInternalDragOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalDragOptionsNormalizers);\n}\n\nfunction _buildMoveConfig(_ref) {\n  var domTarget = _ref.domTarget,\n      eventOptions = _ref.eventOptions,\n      window = _ref.window,\n      enabled = _ref.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.move = getInternalCoordinatesOptions(rest);\n  return opts;\n}\n\nfunction _buildHoverConfig(_ref2) {\n  var domTarget = _ref2.domTarget,\n      eventOptions = _ref2.eventOptions,\n      window = _ref2.window,\n      enabled = _ref2.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref2, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.hover = _extends({\n    enabled: true\n  }, rest);\n  return opts;\n}\n\nfunction _buildDragConfig(_ref3) {\n  var domTarget = _ref3.domTarget,\n      eventOptions = _ref3.eventOptions,\n      window = _ref3.window,\n      enabled = _ref3.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref3, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.drag = getInternalDragOptions(rest);\n  return opts;\n}\n\nfunction _buildPinchConfig(_ref4) {\n  var domTarget = _ref4.domTarget,\n      eventOptions = _ref4.eventOptions,\n      window = _ref4.window,\n      enabled = _ref4.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref4, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.pinch = getInternalDistanceAngleOptions(rest);\n  return opts;\n}\n\nfunction _buildScrollConfig(_ref5) {\n  var domTarget = _ref5.domTarget,\n      eventOptions = _ref5.eventOptions,\n      window = _ref5.window,\n      enabled = _ref5.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref5, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.scroll = getInternalCoordinatesOptions(rest);\n  return opts;\n}\n\nfunction _buildWheelConfig(_ref6) {\n  var domTarget = _ref6.domTarget,\n      eventOptions = _ref6.eventOptions,\n      window = _ref6.window,\n      enabled = _ref6.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref6, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.wheel = getInternalCoordinatesOptions(rest);\n  return opts;\n}\n\nfunction buildComplexConfig(config, actions) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (actions === void 0) {\n    actions = new Set();\n  }\n\n  var _config = config,\n      drag = _config.drag,\n      wheel = _config.wheel,\n      move = _config.move,\n      scroll = _config.scroll,\n      pinch = _config.pinch,\n      hover = _config.hover,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      transform = _config.transform,\n      domTarget = _config.domTarget,\n      enabled = _config.enabled;\n  var mergedConfig = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    transform: transform,\n    window: window,\n    enabled: enabled\n  });\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag);\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move);\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n  if (actions.has('onHover')) mergedConfig.hover = _extends({\n    enabled: true\n  }, hover);\n  return mergedConfig;\n}\n\nfunction getInitial(mixed) {\n  return _extends({\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [[-Infinity, Infinity], [-Infinity, Infinity]],\n    _lastEventType: undefined,\n    _dragStarted: false,\n    _dragPreventScroll: false,\n    _dragIsTap: true,\n    _dragDelayed: false,\n    event: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined\n  }, mixed);\n}\n\nfunction getInitialState() {\n  var shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n    locked: false\n  };\n  var drag = getInitial({\n    _pointerId: undefined,\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0,\n    tap: false,\n    swipe: [0, 0]\n  });\n  var pinch = getInitial({\n    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]\n    _pointerIds: [],\n    da: [0, 0],\n    vdva: [0, 0],\n    // @ts-expect-error origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0\n  });\n  var wheel = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var move = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var scroll = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  return {\n    shared: shared,\n    drag: drag,\n    pinch: pinch,\n    wheel: wheel,\n    move: move,\n    scroll: scroll\n  };\n}\n\nvar RecognizersMap = /*#__PURE__*/new Map();\n\nvar identity$1 = function identity(xy) {\n  return xy;\n};\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n */\n\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(controller, args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    this.controller = controller;\n    this.args = args;\n    this.debounced = true; // Convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n\n      if (ms === void 0) {\n        ms = 140;\n      }\n\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // Convenience method to clear a timeout for a given gesture\n\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    };\n    /**\r\n     * Fires the gesture handler\r\n     */\n\n\n    this.fireGestureHandler = function (forceFlag) {\n      if (forceFlag === void 0) {\n        forceFlag = false;\n      }\n      /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */\n\n\n      if (_this.state._blocked) {\n        // we need debounced gestures to end by themselves\n        if (!_this.debounced) {\n          _this.state._active = false;\n\n          _this.clean();\n        }\n\n        return null;\n      } // If the gesture has no intentional dimension, don't fire the handler.\n\n\n      if (!forceFlag && !_this.state.intentional && !_this.config.triggerAllEvents) return null;\n\n      if (_this.state.intentional) {\n        var prev_active = _this.state.active;\n        var next_active = _this.state._active;\n        _this.state.active = next_active;\n        _this.state.first = next_active && !prev_active;\n        _this.state.last = prev_active && !next_active;\n        _this.controller.state.shared[_this.ingKey] = next_active; // Sets dragging, pinching, etc. to the gesture active state\n      }\n\n      var touches = _this.controller.pointerIds.size || _this.controller.touchIds.size;\n      var down = _this.controller.state.shared.buttons > 0 || touches > 0;\n\n      var state = _extends({}, _this.controller.state.shared, _this.state, _this.mapStateValues(_this.state), {\n        locked: !!document.pointerLockElement,\n        touches: touches,\n        down: down\n      }); // @ts-expect-error\n\n\n      var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n\n\n      _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo;\n      return state;\n    };\n  } // Returns the gesture config\n\n\n  var _proto = Recognizer.prototype; // Convenience method to update the shared state\n\n  _proto.updateSharedState = function updateSharedState(sharedState) {\n    Object.assign(this.controller.state.shared, sharedState);\n  } // Convenience method to update the gesture state\n  ;\n\n  _proto.updateGestureState = function updateGestureState(gestureState) {\n    Object.assign(this.state, gestureState);\n  }\n  /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    return {\n      _intentional: _intentional,\n      _blocked: false\n    };\n  }\n  /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */\n  ;\n\n  _proto.getMovement = function getMovement(values) {\n    var _this$config = this.config,\n        rubberband = _this$config.rubberband,\n        T = _this$config.threshold;\n    var _this$state = this.state,\n        _bounds = _this$state._bounds,\n        _initial = _this$state._initial,\n        _active = _this$state._active,\n        wasIntentional = _this$state._intentional,\n        lastOffset = _this$state.lastOffset,\n        prevMovement = _this$state.movement;\n    var M = this.getInternalMovement(values, this.state);\n\n    var _T = this.transform(T).map(Math.abs);\n\n    var i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0];\n    var i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1]; // Get gesture specific state properties based on intentionality and movement.\n\n    var intentionalityCheck = this.checkIntentionality([i0, i1], M);\n\n    if (intentionalityCheck._blocked) {\n      return _extends({}, intentionalityCheck, {\n        _movement: M,\n        delta: [0, 0]\n      });\n    }\n\n    var _intentional = intentionalityCheck._intentional;\n    var _movement = M;\n    /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */\n\n    var movement = [_intentional[0] !== false ? M[0] - _intentional[0] : 0, _intentional[1] !== false ? M[1] - _intentional[1] : 0];\n    var offset = addV(movement, lastOffset);\n    /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */\n\n    var _rubberband = _active ? rubberband : [0, 0];\n\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband);\n    return _extends({}, intentionalityCheck, {\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial: _initial,\n      _movement: _movement,\n      movement: movement,\n      values: values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement)\n    });\n  } // Cleans the gesture. Can be overriden by gestures.\n  ;\n\n  _proto.clean = function clean() {\n    this.clearTimeout();\n  };\n\n  _createClass(Recognizer, [{\n    key: \"config\",\n    get: function get() {\n      return this.controller.config[this.stateKey];\n    } // Is the gesture enabled\n\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.config.enabled;\n    } // Returns the controller state for a given gesture\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    } // Returns the gesture handler\n\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.controller.handlers[this.stateKey];\n    }\n  }, {\n    key: \"transform\",\n    get: function get() {\n      return this.config.transform || this.controller.config.transform || identity$1;\n    }\n  }]);\n\n  return Recognizer;\n}(); //--------------------------------------------\n\n\nfunction getIntentionalDisplacement(movement, threshold) {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold;\n  } else {\n    return false;\n  }\n}\n\nfunction computeRubberband(bounds, _ref, _ref2) {\n  var Vx = _ref[0],\n      Vy = _ref[1];\n  var Rx = _ref2[0],\n      Ry = _ref2[1];\n  var _bounds$ = bounds[0],\n      X1 = _bounds$[0],\n      X2 = _bounds$[1],\n      _bounds$2 = bounds[1],\n      Y1 = _bounds$2[0],\n      Y2 = _bounds$2[1];\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)];\n}\n/**\r\n * Returns a generic, common payload for all gestures from an event.\r\n */\n\n\nfunction getGenericPayload(_ref3, event, isStartEvent) {\n  var state = _ref3.state;\n  var timeStamp = event.timeStamp,\n      _lastEventType = event.type;\n  var previous = state.values;\n  var elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime;\n  return {\n    _lastEventType: _lastEventType,\n    event: event,\n    timeStamp: timeStamp,\n    elapsedTime: elapsedTime,\n    previous: previous\n  };\n}\n/**\r\n * Returns the reinitialized start state for the gesture.\r\n * Should be common to all gestures.\r\n */\n\n\nfunction getStartGestureState(_ref4, values, event) {\n  var state = _ref4.state,\n      config = _ref4.config,\n      stateKey = _ref4.stateKey,\n      args = _ref4.args;\n  var offset = state.offset;\n  var startTime = event.timeStamp;\n  var initial = config.initial,\n      bounds = config.bounds;\n\n  var _state = _extends({}, getInitialState()[stateKey], {\n    _active: true,\n    args: args,\n    values: values,\n    initial: values,\n    offset: offset,\n    lastOffset: offset,\n    startTime: startTime\n  });\n\n  return _extends({}, _state, {\n    _initial: valueFn(initial, _state),\n    _bounds: valueFn(bounds, _state)\n  });\n}\n\nfunction partial(func, state) {\n  return function (event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    } // @ts-ignore\n\n\n    return func.call.apply(func, [this, _extends({}, state, {\n      event: event\n    })].concat(args));\n  };\n}\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n */\n\n\nvar Controller = function Controller(classes) {\n  var _this = this;\n\n  this.classes = classes;\n  this.pointerIds = new Set(); // register Pointer Events pointerIds\n\n  this.touchIds = new Set(); // register Touch Events identifiers\n\n  this.supportsTouchEvents = supportsTouchEvents();\n  this.supportsGestureEvents = supportsGestureEvents();\n\n  this.bind = function () {\n    var bindings = {};\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(_this.classes), _step; !(_step = _iterator()).done;) {\n      var RecognizerClass = _step.value;\n      new RecognizerClass(_this, args).addBindings(bindings);\n    } // we also add event bindings for native handlers\n\n\n    for (var _i = 0, _Object$entries = Object.entries(_this.nativeRefs); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n          event = _Object$entries$_i[0],\n          handler = _Object$entries$_i[1];\n      addBindings(bindings, event, partial(handler, _extends({}, _this.state.shared, {\n        args: args\n      })));\n    }\n\n    if (_this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(_this, bindings);\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(_this, bindings);\n    }\n  };\n\n  this.effect = function () {\n    if (_this.config.domTarget) _this.bind();\n    return _this.clean;\n  };\n  /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */\n\n\n  this.clean = function () {\n    var domTarget = getDomTargetFromConfig(_this.config);\n    var eventOptions = _this.config.eventOptions;\n    if (domTarget) removeListeners(domTarget, takeAll(_this.domListeners), eventOptions);\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    clearAllWindowListeners(_this);\n  };\n\n  this.state = getInitialState();\n  this.timeouts = {};\n  this.domListeners = [];\n  this.windowListeners = {};\n};\n\nfunction addEventIds(controller, event) {\n  var idList = 'pointerId' in event ? controller.pointerIds : controller.touchIds;\n  getPointerIds(event).forEach(idList.add, idList);\n}\n\nfunction removeEventIds(controller, event) {\n  var idList = 'pointerId' in event ? controller.pointerIds : controller.touchIds;\n  getPointerIds(event).forEach(idList[\"delete\"], idList);\n}\n\nfunction clearAllWindowListeners(controller) {\n  var _controller$config = controller.config,\n      el = _controller$config.window,\n      eventOptions = _controller$config.eventOptions,\n      windowListeners = controller.windowListeners;\n  if (!el) return;\n\n  for (var stateKey in windowListeners) {\n    var handlers = windowListeners[stateKey];\n    removeListeners(el, handlers, eventOptions);\n  }\n\n  controller.windowListeners = {};\n}\n\nfunction clearWindowListeners(_ref, stateKey, options) {\n  var config = _ref.config,\n      windowListeners = _ref.windowListeners;\n\n  if (options === void 0) {\n    options = config.eventOptions;\n  }\n\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], options);\n  delete windowListeners[stateKey];\n}\n\nfunction updateWindowListeners(_ref2, stateKey, listeners, options) {\n  var config = _ref2.config,\n      windowListeners = _ref2.windowListeners;\n\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (options === void 0) {\n    options = config.eventOptions;\n  }\n\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], options);\n  addListeners(config.window, windowListeners[stateKey] = listeners, options);\n}\n\nfunction updateDomListeners(_ref3, bindings) {\n  var config = _ref3.config,\n      domListeners = _ref3.domListeners;\n  var domTarget = getDomTargetFromConfig(config);\n  if (!domTarget) throw new Error('domTarget must be defined');\n  var eventOptions = config.eventOptions;\n  removeListeners(domTarget, takeAll(domListeners), eventOptions);\n\n  for (var _i2 = 0, _Object$entries2 = Object.entries(bindings); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _Object$entries2[_i2],\n        key = _Object$entries2$_i[0],\n        fns = _Object$entries2$_i[1];\n    var name = key.slice(2).toLowerCase();\n    domListeners.push([name, chainFns.apply(void 0, fns)]);\n  }\n\n  addListeners(domTarget, domListeners, eventOptions);\n}\n\nfunction getPropsListener(_ref4, bindings) {\n  var config = _ref4.config;\n  var props = {};\n  var captureString = config.eventOptions.capture ? 'Capture' : '';\n\n  for (var _i3 = 0, _Object$entries3 = Object.entries(bindings); _i3 < _Object$entries3.length; _i3++) {\n    var _Object$entries3$_i = _Object$entries3[_i3],\n        event = _Object$entries3$_i[0],\n        fns = _Object$entries3$_i[1];\n    var fnsArray = Array.isArray(fns) ? fns : [fns];\n    var key = event + captureString;\n    props[key] = chainFns.apply(void 0, fnsArray);\n  }\n\n  return props;\n}\n\nfunction takeAll(array) {\n  if (array === void 0) {\n    array = [];\n  }\n\n  return array.splice(0, array.length);\n}\n\nfunction getDomTargetFromConfig(_ref5) {\n  var domTarget = _ref5.domTarget;\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n}\n/**\r\n * bindings is an object which keys match ReactEventHandlerKeys.\r\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n * that key.\r\n */\n\n\nfunction addBindings(bindings, name, fn) {\n  if (!bindings[name]) bindings[name] = [];\n  bindings[name].push(fn);\n}\n\nfunction addListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(listeners), _step2; !(_step2 = _iterator2()).done;) {\n    var _step2$value = _step2.value,\n        eventName = _step2$value[0],\n        eventHandler = _step2$value[1];\n    el.addEventListener(eventName, eventHandler, options);\n  }\n}\n\nfunction removeListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(listeners), _step3; !(_step3 = _iterator3()).done;) {\n    var _step3$value = _step3.value,\n        eventName = _step3$value[0],\n        eventHandler = _step3$value[1];\n    el.removeEventListener(eventName, eventHandler, options);\n  }\n}\n/* eslint-disable react-hooks/exhaustive-deps */\n\n/**\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param handlers\r\n * @param classes\r\n * @param config\r\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n */\n\n\nfunction useRecognizers(handlers, config, nativeHandlers) {\n  if (nativeHandlers === void 0) {\n    nativeHandlers = {};\n  }\n\n  var classes = resolveClasses(handlers);\n  var controller = React.useMemo(function () {\n    return new Controller(classes);\n  }, []);\n  controller.config = config;\n  controller.handlers = handlers;\n  controller.nativeRefs = nativeHandlers;\n  React.useEffect(controller.effect, []); // @ts-ignore\n\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget; // @ts-ignore\n\n  return controller.bind;\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\"Deprecation notice: When the `domTarget` option is specified, you don't need to write `useEffect(bind, [bind])` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when `domTarget` is provided, therefore your code will break if you try to call `useEffect`.\");\n  }\n}\n\nfunction resolveClasses(internalHandlers) {\n  var classes = new Set();\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag'));\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel'));\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll'));\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move'));\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch'));\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover'));\n  return classes;\n}\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n */\n\n\nvar CoordinatesRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = CoordinatesRecognizer.prototype;\n  /**\r\n   * Returns the real movement (without taking intentionality into account)\r\n   */\n\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    return subV(values, state.initial);\n  }\n  /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return {\n        _intentional: _intentional,\n        axis: this.state.axis\n      };\n    }\n\n    var _movement$map = _movement.map(Math.abs),\n        absX = _movement$map[0],\n        absY = _movement$map[1];\n\n    var axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined);\n    if (!this.config.axis && !this.config.lockDirection) return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n    if (!axis) return {\n      _intentional: [false, false],\n      _blocked: false,\n      axis: axis\n    };\n    if (!!this.config.axis && axis !== this.config.axis) return {\n      _intentional: _intentional,\n      _blocked: true,\n      axis: axis\n    };\n    _intentional[axis === 'x' ? 1 : 0] = false;\n    return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n\n    if (!state._blocked) {\n      var dt = event.timeStamp - this.state.timeStamp;\n      Object.assign(state, calculateAllKinematics(state.movement, state.delta, dt));\n    }\n\n    return state;\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      xy: state.values,\n      vxvy: state.velocities\n    };\n  };\n\n  return CoordinatesRecognizer;\n}(Recognizer);\n\nvar TAP_DISTANCE_THRESHOLD = 3;\nvar SWIPE_MAX_ELAPSED_TIME = 220;\n\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nvar DragRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n\n  function DragRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'dragging';\n    _this.stateKey = 'drag'; // TODO add back when setPointerCapture is widely wupported\n    // https://caniuse.com/#search=setPointerCapture\n\n    _this.setPointerCapture = function (event) {\n      // don't perform pointere capture when user wants to use touch events or\n      // when a pointerLockElement exists as this would throw an error\n      if (_this.config.useTouch || document.pointerLockElement) return;\n      var target = event.target,\n          pointerId = event.pointerId;\n\n      if (target && 'setPointerCapture' in target) {\n        // this would work in the DOM but doesn't with react three fiber\n        // target.addEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n        // @ts-expect-error\n        target.setPointerCapture(pointerId);\n      }\n\n      _this.updateGestureState({\n        _dragTarget: target,\n        _dragPointerId: pointerId\n      });\n    };\n\n    _this.releasePointerCapture = function () {\n      if (_this.config.useTouch || document.pointerLockElement) return;\n      var _this$state = _this.state,\n          _dragTarget = _this$state._dragTarget,\n          _dragPointerId = _this$state._dragPointerId;\n\n      if (_dragPointerId && _dragTarget && 'releasePointerCapture' in _dragTarget) {\n        // this would work in the DOM but doesn't with react three fiber\n        // target.removeEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n        if (!('hasPointerCapture' in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId)) try {\n          _dragTarget.releasePointerCapture(_dragPointerId);\n        } catch (e) {}\n      }\n    };\n\n    _this.preventScroll = function (event) {\n      if (_this.state._dragPreventScroll && event.cancelable) {\n        event.preventDefault();\n      }\n    };\n\n    _this.getEventId = function (event) {\n      if (_this.config.useTouch) return event.changedTouches[0].identifier;\n      return event.pointerId;\n    };\n\n    _this.isValidEvent = function (event) {\n      // if we were using pointer events only event.isPrimary === 1 would suffice\n      return _this.state._pointerId === _this.getEventId(event);\n    };\n\n    _this.shouldPreventWindowScrollY = _this.config.experimental_preventWindowScrollY && _this.controller.supportsTouchEvents;\n\n    _this.setUpWindowScrollDetection = function (event) {\n      persistEvent(event); // we add window listeners that will prevent the scroll when the user has started dragging\n\n      updateWindowListeners(_this.controller, _this.stateKey, [['touchmove', _this.preventScroll], ['touchend', _this.clean.bind(_assertThisInitialized(_this))], ['touchcancel', _this.clean.bind(_assertThisInitialized(_this))]], {\n        passive: false\n      });\n\n      _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), 250, event);\n    };\n\n    _this.setUpDelayedDragTrigger = function (event) {\n      _this.state._dragDelayed = true;\n      persistEvent(event);\n\n      _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), _this.config.delay, event);\n    };\n\n    _this.setStartState = function (event) {\n      var values = getPointerEventValues(event, _this.transform);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        _pointerId: _this.getEventId(event)\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n    };\n\n    _this.onDragStart = function (event) {\n      addEventIds(_this.controller, event);\n      if (!_this.enabled || _this.state._active) return;\n\n      _this.setStartState(event);\n\n      _this.setPointerCapture(event);\n\n      if (_this.shouldPreventWindowScrollY) _this.setUpWindowScrollDetection(event);else if (_this.config.delay > 0) _this.setUpDelayedDragTrigger(event);else _this.startDrag(event, true); // we pass the values to the startDrag event\n    };\n\n    _this.onDragChange = function (event) {\n      if ( // if the gesture was canceled or\n      _this.state.canceled || // if onDragStart wasn't fired or\n      !_this.state._active || // if the event pointerId doesn't match the one that initiated the drag\n      !_this.isValidEvent(event)) return;\n      var values;\n\n      if (document.pointerLockElement) {\n        var movementX = event.movementX,\n            movementY = event.movementY;\n        values = addV(_this.transform([movementX, movementY]), _this.state.values);\n      } else values = getPointerEventValues(event, _this.transform);\n\n      var kinematics = _this.getKinematics(values, event); // if startDrag hasn't fired\n\n\n      if (!_this.state._dragStarted) {\n        // If the gesture isn't active then respond to the event only if\n        // it's been delayed via the `delay` option, in which case start\n        // the gesture immediately.\n        if (_this.state._dragDelayed) {\n          _this.startDrag(event);\n\n          return;\n        } // if the user wants to prevent vertical window scroll when user starts dragging\n\n\n        if (_this.shouldPreventWindowScrollY) {\n          if (!_this.state._dragPreventScroll && kinematics.axis) {\n            // if the user is dragging horizontally then we should allow the drag\n            if (kinematics.axis === 'x') {\n              _this.startDrag(event);\n            } else {\n              _this.state._active = false;\n              return;\n            }\n          } else return;\n        } else return;\n      }\n\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var genericPayload = getGenericPayload(_assertThisInitialized(_this), event); // This verifies if the drag can be assimilated to a tap by checking\n      // if the real distance of the drag (ie not accounting for the threshold) is\n      // greater than the TAP_DISTANCE_THRESHOLD.\n\n      var realDistance = calculateDistance(kinematics._movement);\n      var _dragIsTap = _this.state._dragIsTap;\n      if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD) _dragIsTap = false;\n\n      _this.updateGestureState(_extends({}, genericPayload, kinematics, {\n        _dragIsTap: _dragIsTap\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onDragEnd = function (event) {\n      removeEventIds(_this.controller, event); // if the event pointerId doesn't match the one that initiated the drag\n      // we don't want to end the drag\n\n      if (!_this.isValidEvent(event)) return;\n\n      _this.clean(); // if the gesture is no longer active (ie canceled)\n      // don't do anything\n\n\n      if (!_this.state._active) return;\n      _this.state._active = false;\n      var tap = _this.state._dragIsTap;\n      var _this$state$velocitie = _this.state.velocities,\n          vx = _this$state$velocitie[0],\n          vy = _this$state$velocitie[1];\n      var _this$state$movement = _this.state.movement,\n          mx = _this$state$movement[0],\n          my = _this$state$movement[1];\n      var _this$state$_intentio = _this.state._intentional,\n          ix = _this$state$_intentio[0],\n          iy = _this$state$_intentio[1];\n      var _this$config$swipeVel = _this.config.swipeVelocity,\n          svx = _this$config$swipeVel[0],\n          svy = _this$config$swipeVel[1];\n      var _this$config$swipeDis = _this.config.swipeDistance,\n          sx = _this$config$swipeDis[0],\n          sy = _this$config$swipeDis[1];\n\n      var endState = _extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values));\n\n      var swipe = [0, 0];\n\n      if (endState.elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n        if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx);\n        if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy);\n      }\n\n      _this.updateSharedState({\n        buttons: 0\n      });\n\n      _this.updateGestureState(_extends({}, endState, {\n        tap: tap,\n        swipe: swipe\n      }));\n\n      _this.fireGestureHandler(_this.config.filterTaps && tap === true);\n    };\n\n    _this.clean = function () {\n      _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n\n      _this.state._dragStarted = false;\n\n      _this.releasePointerCapture();\n\n      clearWindowListeners(_this.controller, _this.stateKey);\n    };\n\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n\n      _this.updateGestureState({\n        canceled: true,\n        _active: false\n      });\n\n      _this.updateSharedState({\n        buttons: 0\n      });\n\n      setTimeout(function () {\n        return _this.fireGestureHandler();\n      }, 0);\n    };\n\n    _this.onClick = function (event) {\n      if (!_this.state._dragIsTap) event.stopPropagation();\n    };\n\n    return _this;\n  }\n\n  var _proto = DragRecognizer.prototype;\n\n  _proto.startDrag = function startDrag(event, onDragIsStart) {\n    if (onDragIsStart === void 0) {\n      onDragIsStart = false;\n    } // startDrag can happen after a timeout, so we need to check if the gesture is still active\n    // as the user might have lift up the pointer in between.\n\n\n    if ( // if the gesture isn't active (probably means)\n    !this.state._active || // if the drag has already started we should ignore subsequent attempts\n    this.state._dragStarted) return;\n    if (!onDragIsStart) this.setStartState(event);\n    this.updateGestureState({\n      _dragStarted: true,\n      _dragPreventScroll: true,\n      cancel: this.onCancel\n    });\n    this.clearTimeout();\n    this.fireGestureHandler();\n  };\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    if (this.config.useTouch) {\n      addBindings(bindings, 'onTouchStart', this.onDragStart);\n      addBindings(bindings, 'onTouchMove', this.onDragChange); // this is needed for react-three-fiber\n\n      addBindings(bindings, 'onTouchEnd', this.onDragEnd);\n      addBindings(bindings, 'onTouchCancel', this.onDragEnd);\n    } else {\n      addBindings(bindings, 'onPointerDown', this.onDragStart);\n      addBindings(bindings, 'onPointerMove', this.onDragChange); // this is needed for react-three-fiber\n\n      addBindings(bindings, 'onPointerUp', this.onDragEnd);\n      addBindings(bindings, 'onPointerCancel', this.onDragEnd);\n    }\n\n    if (this.config.filterTaps) {\n      var handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture';\n      addBindings(bindings, handler, this.onClick);\n    }\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Inlined from https://github.com/alexreardon/memoize-one\r\n */\n\n\nfunction memoizeOne(resultFn, isEqual) {\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n\n  function memoized() {\n    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  }\n\n  return memoized;\n}\n/**\r\n * Taken from https://github.com/FormidableLabs/react-fast-compare\r\n *\r\n * Dropped comments and ArrayBuffer handling\r\n */\n\n\nfunction equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length, i, keys;\n\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    var it;\n\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!equal(i.value[1], b.get(i.value[0]))) return false;\n      }\n\n      return true;\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n\n      return true;\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (keys[i] === '_owner' && a.$$typeof) continue;\n      if (!equal(a[keys[i]], b[keys[i]])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise  NaN !== NaN  true\n  // eslint-disable-next-line no-self-compare\n\n\n  return a !== a && b !== b;\n}\n\nfunction isEqual(a, b) {\n  try {\n    return equal(a, b);\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      console.warn('react-fast-compare cannot handle circular refs');\n      return false;\n    }\n\n    throw error;\n  }\n}\n/**\r\n * Drag hook.\r\n *\r\n * @param handler - the function fired every time the drag gesture updates\r\n * @param [config={}] - the config object including generic options and drag options\r\n */\n\n\nfunction useDrag(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('drag', DragRecognizer);\n  var buildDragConfig = useRef();\n\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoizeOne(_buildDragConfig, isEqual);\n  }\n\n  return useRecognizers({\n    drag: handler\n  }, buildDragConfig.current(config));\n}\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */\n\n\nvar DistanceAngleRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n\n  function DistanceAngleRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = DistanceAngleRecognizer.prototype;\n\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    var prev_a = state.values[1]; // not be defined if ctrl+wheel is used for zoom only\n\n    var d = values[0],\n        _values$ = values[1],\n        a = _values$ === void 0 ? prev_a : _values$;\n    var delta_a = a - prev_a;\n    var next_turns = state.turns;\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a);\n    return subV([d, a - 360 * next_turns], state.initial);\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n    var turns = (values[1] - state._movement[1] - this.state.initial[1]) / 360;\n    var dt = event.timeStamp - this.state.timeStamp;\n\n    var _calculateAllKinemati = calculateAllKinematics(state.movement, state.delta, dt),\n        kinematics = _objectWithoutPropertiesLoose(_calculateAllKinemati, [\"distance\", \"velocity\"]);\n\n    return _extends({\n      turns: turns\n    }, state, kinematics);\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      da: state.values,\n      vdva: state.velocities\n    };\n  };\n\n  return DistanceAngleRecognizer;\n}(Recognizer);\n\nvar PinchRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n\n  function PinchRecognizer() {\n    var _this;\n\n    _this = _DistanceAngleRecogni.apply(this, arguments) || this;\n    _this.ingKey = 'pinching';\n    _this.stateKey = 'pinch';\n\n    _this.onPinchStart = function (event) {\n      addEventIds(_this.controller, event);\n      if (!_this.enabled || _this.state._active) return; // until we reach two fingers on the target don't react\n\n      if (_this.controller.touchIds.size < 2) return;\n\n      var _pointerIds = Array.from(_this.controller.touchIds).slice(0, 2);\n\n      var _getTwoTouchesEventVa = getTwoTouchesEventValues(event, _pointerIds, _this.transform),\n          values = _getTwoTouchesEventVa.values,\n          origin = _getTwoTouchesEventVa.origin;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        _pointerIds: _pointerIds,\n        cancel: _this.onCancel,\n        origin: origin\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n          canceled = _this$state.canceled,\n          _active = _this$state._active;\n      if (canceled || !_active) return;\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getTwoTouchesEventVa2 = getTwoTouchesEventValues(event, _this.state._pointerIds, _this.transform),\n          values = _getTwoTouchesEventVa2.values,\n          origin = _getTwoTouchesEventVa2.origin;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n        origin: origin\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchEnd = function (event) {\n      removeEventIds(_this.controller, event);\n      var pointerIds = getPointerIds(event); // if none of the lifted pointerIds is in the state pointerIds don't do anything\n\n      if (_this.state._pointerIds.every(function (id) {\n        return !pointerIds.includes(id);\n      })) return;\n\n      _this.clean();\n\n      if (!_this.state._active) return;\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {\n        _active: false\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n\n      _this.updateGestureState({\n        _active: false,\n        canceled: true\n      });\n\n      setTimeout(function () {\n        return _this.fireGestureHandler();\n      }, 0);\n    };\n    /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */\n\n\n    _this.onGestureStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault(); // useless\n\n      var values = getWebkitGestureEventValues(event, _this.transform);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        origin: [event.clientX, event.clientY],\n        cancel: _this.onCancel\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureChange = function (event) {\n      var _this$state2 = _this.state,\n          canceled = _this$state2.canceled,\n          _active = _this$state2._active;\n      if (canceled || !_active) return;\n      event.preventDefault();\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var values = getWebkitGestureEventValues(event, _this.transform);\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n        origin: [event.clientX, event.clientY]\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureEnd = function (event) {\n      _this.clean();\n\n      if (!_this.state._active) return;\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {\n        _active: false,\n        origin: [event.clientX, event.clientY]\n      }));\n\n      _this.fireGestureHandler();\n    };\n    /**\r\n     * PINCH WITH WHEEL\r\n     */\n\n\n    _this.wheelShouldRun = function (event) {\n      return _this.enabled && event.ctrlKey;\n    };\n\n    _this.getWheelValuesFromEvent = function (event) {\n      var _getWheelEventValues = getWheelEventValues(event, _this.transform),\n          delta_d = _getWheelEventValues[1];\n\n      var _this$state$values = _this.state.values,\n          prev_d = _this$state$values[0],\n          prev_a = _this$state$values[1];\n      var d = prev_d - delta_d;\n      var a = prev_a !== void 0 ? prev_a : 0;\n      return {\n        values: [d, a],\n        origin: [event.clientX, event.clientY],\n        delta: [0, delta_d]\n      };\n    };\n\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n\n      _this.setTimeout(_this.onWheelEnd);\n\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n\n    _this.onWheelStart = function (event) {\n      var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF.values,\n          delta = _this$getWheelValuesF.delta,\n          origin = _this$getWheelValuesF.origin;\n\n      if (event.cancelable) event.preventDefault();else if (process.env.NODE_ENV === 'development') {\n        console.warn('To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.');\n      }\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        initial: _this.state.values,\n        offset: values,\n        delta: delta,\n        origin: origin\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelChange = function (event) {\n      if (event.cancelable) event.preventDefault();\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF2.values,\n          origin = _this$getWheelValuesF2.origin,\n          delta = _this$getWheelValuesF2.delta;\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event), {\n        origin: origin,\n        delta: delta\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelEnd = function () {\n      _this.clean();\n\n      if (!_this.state._active) return;\n      _this.state._active = false;\n\n      _this.updateGestureState(_this.getMovement(_this.state.values));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && !this.controller.supportsTouchEvents && this.controller.supportsGestureEvents) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart);\n      addBindings(bindings, 'onGestureChange', this.onGestureChange);\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd);\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart);\n      addBindings(bindings, 'onTouchMove', this.onPinchChange);\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd);\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd);\n      addBindings(bindings, 'onWheel', this.onWheel);\n    }\n  };\n\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n/**\r\n * Pinch hook.\r\n *\r\n * @param handler - the function fired every time the pinch gesture updates\r\n * @param [config={}] - the config object including generic options and pinch options\r\n */\n\n\nfunction usePinch(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('pinch', PinchRecognizer);\n  var buildPinchConfig = useRef();\n\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoizeOne(_buildPinchConfig, isEqual);\n  }\n\n  return useRecognizers({\n    pinch: handler\n  }, buildPinchConfig.current(config));\n}\n\nvar WheelRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n\n  function WheelRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'wheeling';\n    _this.stateKey = 'wheel';\n    _this.debounced = true;\n\n    _this.handleEvent = function (event) {\n      if (event.ctrlKey && 'pinch' in _this.controller.handlers) return;\n      if (!_this.enabled) return;\n\n      _this.setTimeout(_this.onEnd);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = addV(getWheelEventValues(event, _this.transform), _this.state.values);\n\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n          initial: _this.state.values\n        }));\n\n        var movement = _this.getMovement(values);\n\n        var geometry = calculateAllGeometry(movement.delta);\n\n        _this.updateGestureState(movement);\n\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onEnd = function () {\n      _this.clean();\n\n      if (!_this.state._active) return;\n\n      var movement = _this.getMovement(_this.state.values);\n\n      _this.updateGestureState(movement);\n\n      _this.updateGestureState({\n        _active: false,\n        velocities: [0, 0],\n        velocity: 0\n      });\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = WheelRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onWheel', this.handleEvent);\n  };\n\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Wheel hook.\r\n *\r\n * @param handler - the function fired every time the wheel gesture updates\r\n * @param the config object including generic options and wheel options\r\n */\n\n\nfunction useWheel(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var buildWheelConfig = useRef();\n\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoizeOne(_buildWheelConfig, isEqual);\n  }\n\n  return useRecognizers({\n    wheel: handler\n  }, buildWheelConfig.current(config));\n}\n\nvar MoveRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n\n  function MoveRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'moving';\n    _this.stateKey = 'move';\n    _this.debounced = true;\n\n    _this.onMove = function (event) {\n      if (!_this.enabled) return;\n\n      _this.setTimeout(_this.onMoveEnd);\n\n      if (!_this.state._active) _this.onMoveStart(event);else _this.onMoveChange(event);\n    };\n\n    _this.onMoveStart = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = getPointerEventValues(event, _this.transform);\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true)));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveChange = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = getPointerEventValues(event, _this.transform);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveEnd = function () {\n      _this.clean();\n\n      if (!_this.state._active) return;\n      var values = _this.state.values;\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.updateGestureState({\n        velocities: [0, 0],\n        velocity: 0,\n        _active: false\n      });\n\n      _this.fireGestureHandler();\n    };\n\n    _this.hoverTransform = function () {\n      return _this.controller.config.hover.transform || _this.controller.config.transform;\n    };\n\n    _this.onPointerEnter = function (event) {\n      _this.controller.state.shared.hovering = true;\n      if (!_this.controller.config.enabled) return;\n\n      if (_this.controller.config.hover.enabled) {\n        var values = getPointerEventValues(event, _this.hoverTransform());\n\n        var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event, true), {\n          args: _this.args,\n          values: values,\n          active: true,\n          hovering: true\n        });\n\n        _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n      }\n\n      if ('move' in _this.controller.handlers) _this.onMoveStart(event);\n    };\n\n    _this.onPointerLeave = function (event) {\n      _this.controller.state.shared.hovering = false;\n      if ('move' in _this.controller.handlers) _this.onMoveEnd();\n      if (!_this.controller.config.hover.enabled) return;\n      var values = getPointerEventValues(event, _this.hoverTransform());\n\n      var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event), {\n        args: _this.args,\n        values: values,\n        active: false\n      });\n\n      _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n    };\n\n    return _this;\n  }\n\n  var _proto = MoveRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove);\n    }\n\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter);\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave);\n    }\n  };\n\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Move hook.\r\n *\r\n * @param handler - the function fired every time the move gesture updates\r\n * @param [config={}] - the config object including generic options and move options\r\n */\n\n\nfunction useMove(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('move', MoveRecognizer);\n  var buildMoveConfig = useRef();\n\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoizeOne(_buildMoveConfig, isEqual);\n  }\n\n  return useRecognizers({\n    move: handler\n  }, buildMoveConfig.current(config));\n}\n/**\r\n * Hover hook.\r\n *\r\n * @param handler - the function fired every time the hover gesture updates\r\n * @param [config={}] - the config object including generic options and hover options\r\n */\n\n\nfunction useHover(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('hover', MoveRecognizer);\n  var buildHoverConfig = useRef();\n\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoizeOne(_buildHoverConfig, isEqual);\n  }\n\n  return useRecognizers({\n    hover: handler\n  }, buildHoverConfig.current(config));\n}\n\nvar ScrollRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n\n  function ScrollRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'scrolling';\n    _this.stateKey = 'scroll';\n    _this.debounced = true;\n\n    _this.handleEvent = function (event) {\n      if (!_this.enabled) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var values = getScrollEventValues(event, _this.transform);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n          initial: _this.state.values\n        }));\n\n        var movementDetection = _this.getMovement(values);\n\n        var geometry = calculateAllGeometry(movementDetection.delta);\n\n        _this.updateGestureState(movementDetection);\n\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onEnd = function () {\n      _this.clean();\n\n      if (!_this.state._active) return;\n\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        _active: false,\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = ScrollRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onScroll', this.handleEvent);\n  };\n\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Scroll hook.\r\n *\r\n * @param handler - the function fired every time the scroll gesture updates\r\n * @param [config={}] - the config object including generic options and scroll options\r\n */\n\n\nfunction useScroll(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  var buildScrollConfig = useRef();\n\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoizeOne(_buildScrollConfig, isEqual);\n  }\n\n  return useRecognizers({\n    scroll: handler\n  }, buildScrollConfig.current(config));\n}\n\nvar RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(handlers) {\n  var _native = {};\n  var handle = {};\n  var actions = new Set();\n\n  for (var key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handle[key] = handlers[key];\n    } else {\n      _native[key] = handlers[key];\n    }\n  }\n\n  return [handle, _native, actions];\n}\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useGesture(_handlers, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _sortHandlers = sortHandlers(_handlers),\n      handlers = _sortHandlers[0],\n      nativeHandlers = _sortHandlers[1],\n      actions = _sortHandlers[2];\n\n  RecognizersMap.set('drag', DragRecognizer);\n  RecognizersMap.set('hover', MoveRecognizer);\n  RecognizersMap.set('move', MoveRecognizer);\n  RecognizersMap.set('pinch', PinchRecognizer);\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var mergedConfig = buildComplexConfig(config, actions);\n  var internalHandlers = {};\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag');\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel');\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll');\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove');\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch');\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover;\n  return useRecognizers(internalHandlers, mergedConfig, nativeHandlers);\n}\n\nfunction includeStartEndHandlers(handlers, handlerKey) {\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  return fn;\n}\n\nexport { addV, rubberbandIfOutOfBounds, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","map":{"version":3,"sources":["../src/utils/math.ts","../src/utils/rubberband.ts","../src/utils/utils.ts","../src/utils/resolveOptionsWith.ts","../src/utils/event.ts","../src/utils/config.ts","../src/hooks/buildConfig.ts","../src/utils/state.ts","../src/recognizers/Recognizer.ts","../src/Controller.ts","../src/hooks/useRecognizers.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/recognizers/DragRecognizer.ts","../src/utils/memoize-one.ts","../src/utils/react-fast-compare.ts","../src/hooks/useDrag.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/PinchRecognizer.ts","../src/hooks/usePinch.ts","../src/recognizers/WheelRecognizer.ts","../src/hooks/useWheel.ts","../src/recognizers/MoveRecognizer.ts","../src/hooks/useMove.ts","../src/hooks/useHover.ts","../src/recognizers/ScrollRecognizer.ts","../src/hooks/useScroll.ts","../src/hooks/useGesture.ts"],"names":["addV","v1","v2","v","subV","calculateDistance","movement","Math","calculateAllGeometry","delta","dl","alpha","direction","distance","calculateAllKinematics","dt","beta","velocity","velocities","sign","x","Number","constant","dimension","rubberband2","rubberbandIfOutOfBounds","position","min","max","minMax","rubberband","noop","chainFns","fns","fn","result","ensureVector","value","fallback","Array","assignDefault","Object","valueFn","args","resolveWith","config","resolvers","key","resolver","WEBKIT_DISTANCE_SCALE_FACTOR","supportsGestureEvents","supportsTouchEvents","event","getPointerIds","getEventTouches","t","getGenericEventData","buttons","shiftKey","altKey","metaKey","ctrlKey","identity","getPointerEventValues","transform","touchEvents","clientX","clientY","getTwoTouchesEventValues","pointerIds","A","B","dx","dy","cx","cy","angle","values","origin","getScrollEventValues","scrollX","scrollY","scrollLeft","scrollTop","currentTarget","LINE_HEIGHT","PAGE_HEIGHT","getWheelEventValues","deltaX","deltaY","deltaMode","getWebkitGestureEventValues","DEFAULT_DRAG_DELAY","DEFAULT_RUBBERBAND","DEFAULT_SWIPE_VELOCITY","DEFAULT_SWIPE_DISTANCE","InternalGestureOptionsNormalizers","threshold","enabled","triggerAllEvents","initial","InternalCoordinatesOptionsNormalizers","axis","lockDirection","bounds","left","Infinity","right","top","bottom","isBrowser","window","InternalGenericOptionsNormalizers","domTarget","undefined","eventOptions","passive","capture","InternalDistanceAngleOptionsNormalizers","distanceBounds","angleBounds","_distanceBounds","D","_angleBounds","InternalDragOptionsNormalizers","useTouch","experimental_preventWindowScrollY","filterTaps","swipeVelocity","swipeDistance","delay","getInternalGenericOptions","getInternalCoordinatesOptions","getInternalDistanceAngleOptions","getInternalDragOptions","_buildMoveConfig","rest","opts","_buildHoverConfig","_buildDragConfig","_buildPinchConfig","_buildScrollConfig","_buildWheelConfig","buildComplexConfig","actions","drag","wheel","move","scroll","pinch","hover","mergedConfig","_active","_blocked","_intentional","_movement","_initial","_bounds","_lastEventType","_dragStarted","_dragPreventScroll","_dragIsTap","_dragDelayed","intentional","offset","lastOffset","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","getInitialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","down","locked","getInitial","_pointerId","xy","vxvy","tap","swipe","_pointerIds","da","vdva","turns","RecognizersMap","Recognizer","updateSharedState","updateGestureState","ms","clearTimeout","checkIntentionality","getMovement","T","wasIntentional","prevMovement","state","M","_T","i0","getIntentionalDisplacement","i1","intentionalityCheck","_rubberband","computeRubberband","clean","forceFlag","prev_active","next_active","document","newMemo","Vx","Vy","Rx","Ry","X1","X2","Y1","Y2","getGenericPayload","isStartEvent","type","getStartGestureState","stateKey","_state","func","Controller","bindings","RecognizerClass","handler","addBindings","partial","updateDomListeners","getPropsListener","getDomTargetFromConfig","removeListeners","takeAll","clearAllWindowListeners","addEventIds","controller","idList","removeEventIds","el","windowListeners","handlers","clearWindowListeners","options","updateWindowListeners","listeners","addListeners","domListeners","name","props","captureString","fnsArray","array","eventName","eventHandler","useRecognizers","nativeHandlers","classes","resolveClasses","React","process","console","internalHandlers","CoordinatesRecognizer","getInternalMovement","absX","absY","getKinematics","mapStateValues","TAP_DISTANCE_THRESHOLD","SWIPE_MAX_ELAPSED_TIME","DragRecognizer","target","pointerId","_dragTarget","_dragPointerId","persistEvent","startDrag","onDragIsStart","onCancel","movementX","movementY","kinematics","genericEventData","genericPayload","realDistance","vx","vy","mx","my","ix","iy","svx","svy","sx","sy","endState","setTimeout","memoizeOne","resultFn","isEqual","lastArgs","calledOnce","newArgs","lastThis","lastResult","a","b","length","i","equal","it","keys","error","useDrag","buildDragConfig","useRef","memoize","DistanceAngleRecognizer","prev_a","d","delta_a","next_turns","PinchRecognizer","delta_d","prev_d","usePinch","buildPinchConfig","WheelRecognizer","geometry","useWheel","buildWheelConfig","MoveRecognizer","useMove","buildMoveConfig","useHover","buildHoverConfig","ScrollRecognizer","movementDetection","useScroll","buildScrollConfig","RE_NOT_NATIVE","native","handle","RegExp","useGesture","_handlers","sortHandlers","includeStartEndHandlers","startKey","handlerKey","endKey"],"mappings":"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","sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\ninterface Kinematics {\n  velocities: number[]\n  velocity: number\n  distance: number\n  direction: number[]\n}\n\nexport function calculateAllGeometry<T extends number[]>(movement: T, delta: T = movement) {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n\n  const direction = delta.map(v => alpha * v) as T\n  const distance = calculateDistance(movement)\n\n  return { distance, direction }\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, dt: number): Kinematics {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n  const beta = dt === 0 ? 0 : 1 / dt\n\n  const velocity = beta * dl\n  const velocities = delta.map(v => beta * v)\n  const direction = delta.map(v => alpha * v)\n  const distance = calculateDistance(movement)\n\n  return { velocities, velocity, distance, direction }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n","function minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n  if (position < min) return -rubberband(min - position, max - min, constant) + min\n  if (position > max) return +rubberband(position - max, max - min, constant) + max\n  return position\n}\n","export function noop() {}\n\n/**\n * TODO Beware that only optimized cases are covered in tests =)\n * TODO Need to cover general case as well\n *\n * @param fns\n */\nexport function chainFns(...fns: Function[]): Function {\n  if (fns.length === 0) return noop\n  if (fns.length === 1) return fns[0]\n\n  return function (this: any) {\n    var result\n    for (let fn of fns) {\n      result = fn.apply(this, arguments) || result\n    }\n    return result\n  }\n}\n\n/**\n * Expects a simple value or 2D vector (an array with 2 elements) and\n * always returns 2D vector. If simple value is passed, returns a\n * vector with this value as both coordinates.\n *\n * @param value\n */\nexport function ensureVector<T>(value: T | [T, T] | undefined, fallback?: T | [T, T]): [T, T] {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected')\n    }\n    value = fallback\n  }\n\n  if (Array.isArray(value)) return value\n  return [value, value]\n}\n\n/**\n * Helper for defining a default value\n *\n * @param value\n * @param fallback\n */\nexport function assignDefault<T extends Object>(value: Partial<T> | undefined, fallback: T): T {\n  return Object.assign({}, fallback, value || {})\n}\n\n/**\n * Resolves getters (functions) by calling them\n * If simple value is given it just passes through\n *\n * @param v\n */\nexport function valueFn<T>(v: T | ((...args: any[]) => T), ...args: any[]): T {\n  if (typeof v === 'function') {\n    // @ts-ignore\n    return v(...args)\n  } else {\n    return v\n  }\n}\n","export type Resolver = (x: any, key: string, obj: object) => any\nexport type ResolverMap = { [k: string]: Resolver | ResolverMap | boolean }\n\nexport function resolveWith<T extends { [k: string]: any }, V extends { [k: string]: any }>(\n  config: Partial<T> = {},\n  resolvers: ResolverMap\n): V {\n  const result: any = {}\n\n  for (const [key, resolver] of Object.entries(resolvers))\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config)\n        break\n      case 'object':\n        result[key] = resolveWith(config[key], resolver)\n        break\n      case 'boolean':\n        if (resolver) result[key] = config[key]\n        break\n    }\n\n  return result\n}\n","import { Vector2, WebKitGestureEvent, DomEvents } from '../types'\n\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport function supportsTouchEvents(): boolean {\n  return typeof window !== 'undefined' && 'ontouchstart' in window\n}\n\nfunction getEventTouches(event: PointerEvent | React.PointerEvent | TouchEvent | React.TouchEvent) {\n  if ('pointerId' in event) return null\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches\n}\n\nexport function getPointerIds(event: PointerEvent | React.PointerEvent | TouchEvent | React.TouchEvent): number[] {\n  if ('pointerId' in event) return [event.pointerId]\n  return Array.from(getEventTouches(event)!).map(t => t.identifier)\n}\n\nexport function getGenericEventData(event: DomEvents) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const { shiftKey, altKey, metaKey, ctrlKey } = event as any // TODO check if this might create some overrides?\n  return { buttons, shiftKey, altKey, metaKey, ctrlKey }\n}\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(\n  event: TouchEvent | React.TouchEvent | React.PointerEvent | PointerEvent,\n  transform = identity\n): Vector2 {\n  const touchEvents = getEventTouches(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return transform([clientX, clientY])\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventValues(\n  event: React.TouchEvent | TouchEvent,\n  pointerIds: [number, number],\n  transform = identity\n) {\n  const [A, B] = Array.from(event.touches).filter(t => pointerIds.includes(t.identifier))\n\n  const dx = B.clientX - A.clientX\n  const dy = B.clientY - A.clientY\n  const cx = (B.clientX + A.clientX) / 2\n  const cy = (B.clientY + A.clientY) / 2\n\n  // const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  const distance = Math.hypot(dx, dy)\n  // FIXME rotation has inconsistant values so we're not using it atm\n  // const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI\n  const values: Vector2 = transform([distance, angle])\n  const origin: Vector2 = transform([cx, cy])\n\n  return { values, origin }\n}\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: React.UIEvent | UIEvent, transform = identity): Vector2 {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0])\n}\n\n// wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\nconst LINE_HEIGHT = 40\nconst PAGE_HEIGHT = 800\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: React.WheelEvent | WheelEvent, transform = identity): Vector2 {\n  let { deltaX, deltaY, deltaMode } = event\n  // normalize wheel values, especially for Firefox\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT\n    deltaY *= LINE_HEIGHT\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT\n    deltaY *= PAGE_HEIGHT\n  }\n  return transform([deltaX, deltaY])\n}\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent, transform = identity): Vector2 {\n  return transform([event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation])\n}\n","import { ensureVector, assignDefault, valueFn } from './utils'\nimport { resolveWith } from './resolveOptionsWith'\n\nimport {\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n  Vector2,\n  Bounds,\n  StateKey,\n  State,\n  CoordinatesKey,\n  DistanceAngleKey,\n} from '../types'\nimport { supportsTouchEvents } from './event'\n\nexport const DEFAULT_DRAG_DELAY = 180\nexport const DEFAULT_RUBBERBAND = 0.15\nexport const DEFAULT_SWIPE_VELOCITY = 0.5\nexport const DEFAULT_SWIPE_DISTANCE = 60\n\nconst InternalGestureOptionsNormalizers = {\n  threshold(value: number | Vector2 = 0) {\n    return ensureVector(value)\n  },\n\n  rubberband(value: number | boolean | Vector2 = 0): Vector2 {\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND)\n      case false:\n        return ensureVector(0)\n      default:\n        return ensureVector(value)\n    }\n  },\n\n  enabled(value = true) {\n    return value\n  },\n\n  triggerAllEvents(value = false) {\n    return value\n  },\n\n  initial(value = 0) {\n    if (typeof value === 'function') return value\n    return ensureVector(value)\n  },\n\n  transform: true,\n}\n\nconst InternalCoordinatesOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n  axis: true,\n  lockDirection(value = false) {\n    return value\n  },\n  bounds(value: Bounds | ((state?: State) => Bounds) = {}) {\n    if (typeof value === 'function')\n      return (state?: State) => InternalCoordinatesOptionsNormalizers.bounds(value(state))\n\n    const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value\n\n    return [\n      [left, right],\n      [top, bottom],\n    ]\n  },\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement\n\nconst InternalGenericOptionsNormalizers = {\n  enabled(value = true) {\n    return value\n  },\n  domTarget: true,\n  window(value = isBrowser ? window : undefined) {\n    return value\n  },\n  eventOptions({ passive = true, capture = false } = {}) {\n    return { passive, capture }\n  },\n  transform: true,\n}\n\nconst InternalDistanceAngleOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n\n  bounds(_value: undefined, _key: string, { distanceBounds = {}, angleBounds = {} }) {\n    const _distanceBounds = (state?: State) => {\n      const D = assignDefault(valueFn(distanceBounds, state), { min: -Infinity, max: Infinity })\n      return [D.min, D.max]\n    }\n\n    const _angleBounds = (state?: State) => {\n      const A = assignDefault(valueFn(angleBounds, state), { min: -Infinity, max: Infinity })\n      return [A.min, A.max]\n    }\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function')\n      return [_distanceBounds(), _angleBounds()]\n\n    return (state?: State) => [_distanceBounds(state), _angleBounds(state)]\n  },\n}\n\nconst InternalDragOptionsNormalizers = {\n  ...InternalCoordinatesOptionsNormalizers,\n\n  useTouch(value = false) {\n    return value && supportsTouchEvents()\n  },\n  experimental_preventWindowScrollY(value = false) {\n    return value\n  },\n  threshold(\n    this: InternalDragOptions,\n    v: number | Vector2 | undefined,\n    _k: string,\n    { filterTaps = false, lockDirection = false, axis = undefined }\n  ) {\n    const A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0) as Vector2\n    this.filterTaps = filterTaps\n    return A\n  },\n\n  swipeVelocity(v: number | Vector2 = DEFAULT_SWIPE_VELOCITY) {\n    return ensureVector(v)\n  },\n  swipeDistance(v: number | Vector2 = DEFAULT_SWIPE_DISTANCE) {\n    return ensureVector(v)\n  },\n\n  delay(value: number | boolean = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY\n      case false:\n        return 0\n      default:\n        return value\n    }\n  },\n}\n\nexport function getInternalGenericOptions(config: GenericOptions = {}): InternalGenericOptions {\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith<GenericOptions, InternalGenericOptions>(config, InternalGenericOptionsNormalizers)\n}\n\nexport function getInternalGestureOptions<T extends StateKey>(\n  config: GestureOptions<T> = {}\n): InternalGestureOptions<T> {\n  return resolveWith<GestureOptions<T>, InternalGestureOptions<T>>(config, InternalGestureOptionsNormalizers)\n}\n\nexport function getInternalCoordinatesOptions<T extends CoordinatesKey>(\n  config: CoordinatesConfig<T> = {}\n): InternalCoordinatesOptions<T> {\n  return resolveWith<CoordinatesConfig<T>, InternalCoordinatesOptions<T>>(config, InternalCoordinatesOptionsNormalizers)\n}\n\nexport function getInternalDistanceAngleOptions<T extends DistanceAngleKey>(\n  config: DistanceAngleConfig<T> = {}\n): InternalDistanceAngleOptions<T> {\n  return resolveWith<DistanceAngleConfig<T>, InternalDistanceAngleOptions<T>>(\n    config,\n    InternalDistanceAngleOptionsNormalizers\n  )\n}\n\nexport function getInternalDragOptions(config: DragConfig = {}): InternalDragOptions {\n  return resolveWith<DragConfig, InternalDragOptions>(config, InternalDragOptionsNormalizers)\n}\n","import {\n  InternalConfig,\n  UseMoveConfig,\n  UseHoverConfig,\n  UseDragConfig,\n  UsePinchConfig,\n  UseScrollConfig,\n  UseWheelConfig,\n} from '../types'\n\nimport {\n  getInternalGenericOptions,\n  getInternalCoordinatesOptions,\n  getInternalDragOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\n\nimport { UseGestureConfig } from '../types'\n\nexport function _buildMoveConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseMoveConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.move = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildHoverConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseHoverConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.hover = { enabled: true, ...rest }\n  return opts\n}\n\nexport function _buildDragConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseDragConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.drag = getInternalDragOptions(rest)\n  return opts\n}\n\nexport function _buildPinchConfig({ domTarget, eventOptions, window, enabled, ...rest }: UsePinchConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.pinch = getInternalDistanceAngleOptions(rest)\n  return opts\n}\n\nexport function _buildScrollConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseScrollConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.scroll = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildWheelConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseWheelConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.wheel = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function buildComplexConfig(config: UseGestureConfig = {}, actions: Set<string> = new Set()) {\n  const { drag, wheel, move, scroll, pinch, hover, eventOptions, window, transform, domTarget, enabled } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions({\n    domTarget,\n    eventOptions,\n    transform,\n    window,\n    enabled,\n  })\n\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag)\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move)\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  if (actions.has('onHover')) mergedConfig.hover = { enabled: true, ...hover }\n\n  return mergedConfig\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2, DragState, PinchState } from '../types'\n\nfunction getInitial<T>(mixed: T): T & CommonGestureState {\n  return {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [\n      [-Infinity, Infinity],\n      [-Infinity, Infinity],\n    ],\n    _lastEventType: undefined,\n    _dragStarted: false,\n    _dragPreventScroll: false,\n    _dragIsTap: true,\n    _dragDelayed: false,\n    event: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n    ...mixed,\n  }\n}\n\nexport function getInitialState(): State {\n  const shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n    locked: false,\n  }\n\n  const drag = getInitial<DragState & Coordinates>({\n    _pointerId: undefined,\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n    tap: false,\n    swipe: [0, 0],\n  })\n\n  const pinch = getInitial<DistanceAngle & PinchState>({\n    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]\n    _pointerIds: [],\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    // @ts-expect-error origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0,\n  })\n\n  const wheel = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const move = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const scroll = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  return { shared, drag, pinch, wheel, move, scroll }\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  IngKey,\n  InternalConfig,\n  GestureKey,\n  GestureState,\n  EventTypes,\n  PartialGestureState,\n  Vector2,\n  FullGestureState,\n  RecognizerClass,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { rubberbandIfOutOfBounds } from '../utils/rubberband'\nimport { subV, addV, sign } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\nexport const RecognizersMap = new Map<GestureKey, RecognizerClass>()\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * @private\n * Recognizer abstract class.\n */\nexport default abstract class Recognizer<T extends StateKey = StateKey> {\n  abstract readonly ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n  abstract readonly stateKey: T\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(readonly controller: Controller, readonly args: any[] = []) {}\n\n  // Returns the gesture config\n  get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  get transform() {\n    return this.config.transform || this.controller.config.transform || identity\n  }\n\n  // Convenience method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Convenience method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  protected abstract getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T>\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  protected abstract mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'>\n\n  public abstract addBindings(bindings: any): void\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2): PartialGestureState<T> {\n    const { rubberband, threshold: T } = this.config\n\n    const { _bounds, _initial, _active, _intentional: wasIntentional, lastOffset, movement: prevMovement } = this.state\n    const M = this.getInternalMovement(values, this.state)\n\n    const _T = this.transform(T).map(Math.abs)\n\n    const i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0]\n    const i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1]\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], M)\n    if (intentionalityCheck._blocked) {\n      return { ...intentionalityCheck, _movement: M, delta: [0, 0] }\n    }\n\n    const _intentional = intentionalityCheck._intentional!\n    const _movement = M\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement: Vector2 = [\n      _intentional[0] !== false ? M[0] - _intentional[0] : 0,\n      _intentional[1] !== false ? M[1] - _intentional[1] : 0,\n    ]\n\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband)\n\n    return {\n      ...intentionalityCheck,\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial,\n      _movement,\n      movement,\n      values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n  }\n\n  /**\n   * Fires the gesture handler\n   */\n  protected fireGestureHandler = (forceFlag: boolean = false): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't fire the handler.\n    if (!forceFlag && !this.state.intentional && !this.config.triggerAllEvents) return null\n\n    if (this.state.intentional) {\n      const prev_active = this.state.active\n      const next_active = this.state._active\n\n      this.state.active = next_active\n      this.state.first = next_active && !prev_active\n      this.state.last = prev_active && !next_active\n\n      this.controller.state.shared[this.ingKey] = next_active // Sets dragging, pinching, etc. to the gesture active state\n    }\n    const touches = this.controller.pointerIds.size || this.controller.touchIds.size\n    const down = this.controller.state.shared.buttons > 0 || touches > 0\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n      locked: !!document.pointerLockElement,\n      touches,\n      down,\n    } as FullGestureState<T>\n\n    // @ts-expect-error\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    return state\n  }\n}\n\n//--------------------------------------------\n\nfunction getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold\n  } else {\n    return false\n  }\n}\n\nfunction computeRubberband(bounds: [Vector2, Vector2], [Vx, Vy]: Vector2, [Rx, Ry]: Vector2): Vector2 {\n  const [[X1, X2], [Y1, Y2]] = bounds\n\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)]\n}\n\n/**\n * Returns a generic, common payload for all gestures from an event.\n */\nexport function getGenericPayload<T extends StateKey>(\n  { state }: Recognizer<T>,\n  event: EventTypes[T],\n  isStartEvent?: boolean\n) {\n  const { timeStamp, type: _lastEventType } = event\n  const previous = state.values\n  const elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime!\n  return { _lastEventType, event, timeStamp, elapsedTime, previous }\n}\n\n/**\n * Returns the reinitialized start state for the gesture.\n * Should be common to all gestures.\n */\nexport function getStartGestureState<T extends StateKey>(\n  { state, config, stateKey, args }: Recognizer<T>,\n  values: Vector2,\n  event: EventTypes[T]\n) {\n  const offset = state.offset\n  const startTime = event.timeStamp\n\n  const { initial, bounds } = config\n\n  const _state = {\n    ...getInitialState()[stateKey],\n    _active: true,\n    args,\n    values,\n    initial: values,\n    offset,\n    lastOffset: offset,\n    startTime,\n  }\n\n  return { ..._state, _initial: valueFn(initial, _state), _bounds: valueFn(bounds, _state) }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n  RecognizerClass,\n} from './types'\nimport { supportsTouchEvents, supportsGestureEvents, getPointerIds } from './utils/event'\nimport { getInitialState } from './utils/state'\nimport { chainFns } from './utils/utils'\n\nfunction partial(func: Fn, state: any) {\n  return function (event: any, ...args: any) {\n    // @ts-ignore\n    return func.call(this, { ...state, event }, ...args)\n  }\n}\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n */\nexport default class Controller {\n  public nativeRefs!: any\n  public config!: InternalConfig\n  public handlers!: InternalHandlers\n  public state: State // state for all gestures\n  public timeouts: { [stateKey in StateKey]?: number } // tracks timeouts of debounced gestures\n  public domListeners: [string, Fn][] // when config.domTarget is set, we attach events directly to the dom\n  public windowListeners: { [stateKey in StateKey]?: [string, Function][] } // keeps track of window listeners added by gestures (drag only at the moment)\n\n  public pointerIds = new Set<number>() // register Pointer Events pointerIds\n  public touchIds = new Set<number>() // register Touch Events identifiers\n  public supportsTouchEvents = supportsTouchEvents()\n  public supportsGestureEvents = supportsGestureEvents()\n\n  constructor(private classes: Set<RecognizerClass>) {\n    this.state = getInitialState()\n    this.timeouts = {}\n    this.domListeners = []\n    this.windowListeners = {}\n  }\n\n  public bind = (...args: any[]) => {\n    const bindings: { [key: string]: Function[] } = {}\n\n    for (let RecognizerClass of this.classes) new RecognizerClass(this, args).addBindings(bindings)\n\n    // we also add event bindings for native handlers\n    for (let [event, handler] of Object.entries(this.nativeRefs))\n      addBindings(bindings, event, partial(handler, { ...this.state.shared, args }))\n\n    if (this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(this, bindings)\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(this, bindings)\n    }\n  }\n\n  public effect = () => {\n    if (this.config.domTarget) this.bind()\n    return this.clean\n  }\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    const domTarget = getDomTargetFromConfig(this.config)\n    const { eventOptions } = this.config\n    if (domTarget) removeListeners(domTarget, takeAll(this.domListeners), eventOptions)\n    Object.values(this.timeouts).forEach(clearTimeout)\n    clearAllWindowListeners(this)\n  }\n}\n\nexport function addEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  const idList = 'pointerId' in event ? controller.pointerIds : controller.touchIds\n  getPointerIds(event).forEach(idList.add, idList)\n}\n\nexport function removeEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  const idList = 'pointerId' in event ? controller.pointerIds : controller.touchIds\n  getPointerIds(event).forEach(idList.delete, idList)\n}\n\nexport function clearAllWindowListeners(controller: Controller) {\n  const {\n    config: { window: el, eventOptions },\n    windowListeners,\n  } = controller\n  if (!el) return\n\n  for (let stateKey in windowListeners) {\n    const handlers = windowListeners[stateKey as StateKey]\n    removeListeners(el, handlers, eventOptions)\n  }\n\n  controller.windowListeners = {}\n}\n\nexport function clearWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  delete windowListeners[stateKey]\n}\n\nexport function updateWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  listeners: [string, Fn][] = [],\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  addListeners(config.window, (windowListeners[stateKey] = listeners), options)\n}\n\nfunction updateDomListeners({ config, domListeners }: Controller, bindings: { [key: string]: Function[] }) {\n  const domTarget = getDomTargetFromConfig(config)\n  if (!domTarget) throw new Error('domTarget must be defined')\n  const { eventOptions } = config\n\n  removeListeners(domTarget, takeAll(domListeners), eventOptions)\n\n  for (let [key, fns] of Object.entries(bindings)) {\n    const name = key.slice(2).toLowerCase()\n    domListeners.push([name, chainFns(...fns)])\n  }\n\n  addListeners(domTarget, domListeners, eventOptions)\n}\n\nfunction getPropsListener({ config }: Controller, bindings: { [key: string]: Function[] }) {\n  const props: ReactEventHandlers = {}\n  const captureString = config.eventOptions.capture ? 'Capture' : ''\n  for (let [event, fns] of Object.entries(bindings)) {\n    const fnsArray = Array.isArray(fns) ? fns : [fns]\n    const key = (event + captureString) as ReactEventHandlerKey\n    props[key] = chainFns(...(fnsArray as Fn[]))\n  }\n  return props\n}\n\nfunction takeAll<T>(array: Array<T> = []) {\n  return array.splice(0, array.length)\n}\n\nfunction getDomTargetFromConfig({ domTarget }: InternalConfig) {\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n}\n\n/**\n * bindings is an object which keys match ReactEventHandlerKeys.\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n * that key.\n */\nexport function addBindings(bindings: any, name: string, fn: Fn): void {\n  if (!bindings[name]) bindings[name] = []\n  bindings[name]!.push(fn)\n}\n\nfunction addListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.addEventListener(eventName, eventHandler, options)\n  }\n}\n\nfunction removeListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.removeEventListener(eventName, eventHandler, options)\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  GenericOptions,\n  RecognizerClass,\n  NativeHandlers,\n} from '../types'\n\n/**\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param handlers\n * @param classes\n * @param config\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  config: InternalConfig,\n  nativeHandlers: Partial<NativeHandlers> = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const classes = resolveClasses(handlers)\n\n  const controller = React.useMemo(() => new Controller(classes), [])\n  controller!.config = config\n  controller!.handlers = handlers\n  controller!.nativeRefs = nativeHandlers\n\n  React.useEffect(controller.effect, [])\n\n  // @ts-ignore\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget\n  // @ts-ignore\n  return controller.bind\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      `Deprecation notice: When the \\`domTarget\\` option is specified, you don't need to write \\`useEffect(bind, [bind])\\` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when \\`domTarget\\` is provided, therefore your code will break if you try to call \\`useEffect\\`.`\n    )\n  }\n}\n\nfunction resolveClasses(internalHandlers: Partial<InternalHandlers>) {\n  const classes = new Set<RecognizerClass>()\n\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag')!)\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel')!)\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll')!)\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move')!)\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch')!)\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover')!)\n\n  return classes\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into account)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return { _intentional, axis: this.state.axis } as PartialGestureState<T>\n    }\n    const [absX, absY] = _movement.map(Math.abs)\n    const axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n    if (!this.config.axis && !this.config.lockDirection) return { _intentional, _blocked: false, axis } as any\n    if (!axis) return { _intentional: [false, false], _blocked: false, axis } as any\n    if (!!this.config.axis && axis !== this.config.axis) return { _intentional, _blocked: true, axis } as any\n    _intentional![axis === 'x' ? 1 : 0] = false\n    return { _intentional, _blocked: false, axis } as any\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    if (!state._blocked) {\n      const dt = event.timeStamp - this.state.timeStamp!\n      Object.assign(state, calculateAllKinematics(state.movement!, state.delta!, dt))\n    }\n    return state\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { xy: state.values, vxvy: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, sign } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, updateWindowListeners, clearWindowListeners, addEventIds, removeEventIds } from '../Controller'\n\nexport const TAP_DISTANCE_THRESHOLD = 3\nexport const SWIPE_MAX_ELAPSED_TIME = 220\n\nfunction persistEvent(event: React.PointerEvent | PointerEvent) {\n  'persist' in event && typeof event.persist === 'function' && event.persist()\n}\n\nexport class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  readonly ingKey = 'dragging'\n  readonly stateKey = 'drag'\n\n  // TODO add back when setPointerCapture is widely wupported\n  // https://caniuse.com/#search=setPointerCapture\n  private setPointerCapture = (event: React.PointerEvent | PointerEvent) => {\n    // don't perform pointere capture when user wants to use touch events or\n    // when a pointerLockElement exists as this would throw an error\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { target, pointerId } = event\n    if (target && 'setPointerCapture' in target) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.addEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      // @ts-expect-error\n      target.setPointerCapture(pointerId)\n    }\n    this.updateGestureState({ _dragTarget: target, _dragPointerId: pointerId })\n  }\n\n  private releasePointerCapture = () => {\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { _dragTarget, _dragPointerId } = this.state\n    if (_dragPointerId && _dragTarget && 'releasePointerCapture' in _dragTarget) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.removeEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      if (!('hasPointerCapture' in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId))\n        try {\n          _dragTarget.releasePointerCapture(_dragPointerId)\n        } catch (e) {}\n    }\n  }\n\n  private preventScroll = (event: TouchEvent) => {\n    if (this.state._dragPreventScroll && event.cancelable) {\n      event.preventDefault()\n    }\n  }\n\n  private getEventId = (event: any): number => {\n    if (this.config.useTouch) return event.changedTouches[0].identifier\n    return event.pointerId\n  }\n\n  private isValidEvent = (event: any) => {\n    // if we were using pointer events only event.isPrimary === 1 would suffice\n    return this.state._pointerId === this.getEventId(event)\n  }\n\n  private shouldPreventWindowScrollY =\n    this.config.experimental_preventWindowScrollY && this.controller.supportsTouchEvents\n\n  private setUpWindowScrollDetection = (event: React.PointerEvent | PointerEvent) => {\n    persistEvent(event)\n    // we add window listeners that will prevent the scroll when the user has started dragging\n    updateWindowListeners(\n      this.controller,\n      this.stateKey,\n      [\n        ['touchmove', this.preventScroll],\n        ['touchend', this.clean.bind(this)],\n        ['touchcancel', this.clean.bind(this)],\n      ],\n      { passive: false }\n    )\n    this.setTimeout(this.startDrag.bind(this), 250, event)\n  }\n\n  private setUpDelayedDragTrigger = (event: React.PointerEvent | PointerEvent) => {\n    this.state._dragDelayed = true\n    persistEvent(event)\n    this.setTimeout(this.startDrag.bind(this), this.config.delay, event)\n  }\n\n  private setStartState = (event: React.PointerEvent | PointerEvent) => {\n    const values = getPointerEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerId: this.getEventId(event), // setting pointerId locks the gesture to this specific event\n    })\n\n    this.updateGestureState(this.getMovement(values))\n  }\n\n  onDragStart = (event: React.PointerEvent | PointerEvent): void => {\n    addEventIds(this.controller, event)\n    if (!this.enabled || this.state._active) return\n\n    this.setStartState(event)\n    this.setPointerCapture(event as PointerEvent)\n\n    if (this.shouldPreventWindowScrollY) this.setUpWindowScrollDetection(event)\n    else if (this.config.delay > 0) this.setUpDelayedDragTrigger(event)\n    else this.startDrag(event, true) // we pass the values to the startDrag event\n  }\n\n  startDrag(event: React.PointerEvent | PointerEvent, onDragIsStart: boolean = false) {\n    // startDrag can happen after a timeout, so we need to check if the gesture is still active\n    // as the user might have lift up the pointer in between.\n\n    if (\n      // if the gesture isn't active (probably means)\n      !this.state._active ||\n      // if the drag has already started we should ignore subsequent attempts\n      this.state._dragStarted\n    )\n      return\n\n    if (!onDragIsStart) this.setStartState(event)\n    this.updateGestureState({ _dragStarted: true, _dragPreventScroll: true, cancel: this.onCancel })\n    this.clearTimeout()\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: PointerEvent): void => {\n    if (\n      // if the gesture was canceled or\n      this.state.canceled ||\n      // if onDragStart wasn't fired or\n      !this.state._active ||\n      // if the event pointerId doesn't match the one that initiated the drag\n      !this.isValidEvent(event)\n    )\n      return\n\n    let values\n\n    if (document.pointerLockElement) {\n      const { movementX, movementY } = event\n      values = addV(this.transform([movementX, movementY]), this.state.values)\n    } else values = getPointerEventValues(event, this.transform)\n\n    const kinematics = this.getKinematics(values, event)\n\n    // if startDrag hasn't fired\n    if (!this.state._dragStarted) {\n      // If the gesture isn't active then respond to the event only if\n      // it's been delayed via the `delay` option, in which case start\n      // the gesture immediately.\n      if (this.state._dragDelayed) {\n        this.startDrag(event)\n        return\n      }\n      // if the user wants to prevent vertical window scroll when user starts dragging\n      if (this.shouldPreventWindowScrollY) {\n        if (!this.state._dragPreventScroll && kinematics.axis) {\n          // if the user is dragging horizontally then we should allow the drag\n          if (kinematics.axis === 'x') {\n            this.startDrag(event)\n          } else {\n            this.state._active = false\n            return\n          }\n        } else return\n      } else return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    const genericPayload = getGenericPayload(this, event)\n\n    // This verifies if the drag can be assimilated to a tap by checking\n    // if the real distance of the drag (ie not accounting for the threshold) is\n    // greater than the TAP_DISTANCE_THRESHOLD.\n    const realDistance = calculateDistance(kinematics._movement!)\n    let { _dragIsTap } = this.state\n    if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD) _dragIsTap = false\n\n    this.updateGestureState({ ...genericPayload, ...kinematics, _dragIsTap })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: PointerEvent): void => {\n    removeEventIds(this.controller, event)\n\n    // if the event pointerId doesn't match the one that initiated the drag\n    // we don't want to end the drag\n    if (!this.isValidEvent(event)) return\n    this.clean()\n\n    // if the gesture is no longer active (ie canceled)\n    // don't do anything\n    if (!this.state._active) return\n    this.state._active = false\n\n    const tap = this.state._dragIsTap\n    const [vx, vy] = this.state.velocities\n    const [mx, my] = this.state.movement\n    const [ix, iy] = this.state._intentional\n    const [svx, svy] = this.config.swipeVelocity\n    const [sx, sy] = this.config.swipeDistance\n\n    const endState = {\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    }\n\n    const swipe: [number, number] = [0, 0]\n\n    if (endState.elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateSharedState({ buttons: 0 })\n    this.updateGestureState({ ...endState, tap, swipe })\n    this.fireGestureHandler(this.config.filterTaps && tap === true)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._dragStarted = false\n    this.releasePointerCapture()\n    clearWindowListeners(this.controller, this.stateKey)\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ canceled: true, _active: false })\n    this.updateSharedState({ buttons: 0 })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n\n  onClick = (event: React.UIEvent | UIEvent): void => {\n    if (!this.state._dragIsTap) event.stopPropagation()\n  }\n\n  addBindings(bindings: any): void {\n    if (this.config.useTouch) {\n      addBindings(bindings, 'onTouchStart', this.onDragStart)\n      addBindings(bindings, 'onTouchMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onTouchEnd', this.onDragEnd)\n      addBindings(bindings, 'onTouchCancel', this.onDragEnd)\n    } else {\n      addBindings(bindings, 'onPointerDown', this.onDragStart)\n      addBindings(bindings, 'onPointerMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onPointerUp', this.onDragEnd)\n      addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n    }\n\n    if (this.config.filterTaps) {\n      const handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture'\n      addBindings(bindings, handler, this.onClick)\n    }\n  }\n}\n","/**\n * Inlined from https://github.com/alexreardon/memoize-one\n */\n\nexport type EqualityFn = (newArgs: any[], lastArgs: any[]) => boolean\n\nexport default function memoizeOne<ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>>(\n  resultFn: ResultFn,\n  isEqual: EqualityFn\n): ResultFn {\n  let lastThis: unknown\n  let lastArgs: unknown[] = []\n  let lastResult: ReturnType<ResultFn>\n  let calledOnce: boolean = false\n\n  function memoized(this: unknown, ...newArgs: unknown[]): ReturnType<ResultFn> {\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult\n    }\n\n    lastResult = resultFn.apply(this, newArgs)\n    calledOnce = true\n    lastThis = this\n    lastArgs = newArgs\n    return lastResult\n  }\n\n  return memoized as ResultFn\n}\n","/**\n * Taken from https://github.com/FormidableLabs/react-fast-compare\n *\n * Dropped comments and ArrayBuffer handling\n */\n\nfunction equal(a: any, b: any): boolean {\n  if (a === b) return true\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false\n\n    let length, i, keys\n    if (Array.isArray(a)) {\n      length = a.length\n      if (length !== b.length) return false\n      for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false\n      return true\n    }\n\n    let it\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!equal(i.value[1], b.get(i.value[0]))) return false\n      return true\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false\n      it = a.entries()\n      while (!(i = it.next()).done) if (!b.has(i.value[0])) return false\n      return true\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf()\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString()\n\n    keys = Object.keys(a)\n    length = keys.length\n    if (length !== Object.keys(b).length) return false\n\n    for (i = length; i-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false\n\n    for (i = length; i-- !== 0; ) {\n      if (keys[i] === '_owner' && a.$$typeof) continue\n      if (!equal(a[keys[i]], b[keys[i]])) return false\n    }\n    return true\n  }\n\n  // true if both NaN, false otherwise  NaN !== NaN  true\n  // eslint-disable-next-line no-self-compare\n  return a !== a && b !== b\n}\n\nexport default function isEqual(a: any, b: any) {\n  try {\n    return equal(a, b)\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      console.warn('react-fast-compare cannot handle circular refs')\n      return false\n    }\n    throw error\n  }\n}\n","import { UseDragConfig, Handler, EventTypes } from '../types'\nimport { _buildDragConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Drag hook.\n *\n * @param handler - the function fired every time the drag gesture updates\n * @param [config={}] - the config object including generic options and drag options\n */\nexport function useDrag<K = EventTypes['drag']>(handler: Handler<'drag', K>, config: UseDragConfig | {} = {}) {\n  RecognizersMap.set('drag', DragRecognizer)\n  const buildDragConfig = useRef<any>()\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoize(_buildDragConfig, isEqual)\n  }\n  return useRecognizers<UseDragConfig>({ drag: handler }, buildDragConfig.current(config))\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, sign, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  protected getInternalMovement(values: [number, number?], state: GestureState<T>): Vector2 {\n    const prev_a = state.values[1]\n    // not be defined if ctrl+wheel is used for zoom only\n    let [d, a = prev_a] = values\n\n    let delta_a = a - prev_a\n    let next_turns = state.turns\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a)\n    return subV([d, a - 360 * next_turns], state.initial)\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    const turns = (values[1] - state._movement![1] - this.state.initial[1]) / 360\n    const dt = event.timeStamp - this.state.timeStamp!\n    const { distance, velocity, ...kinematics } = calculateAllKinematics(state.movement!, state.delta!, dt)\n    return { turns, ...state, ...kinematics }\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { da: state.values, vdva: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n\n/**\n * @param dangle is a small change of variable on \"lifting\" of the circle.\n * It's expected to be small and cannot be greater than 270 or under -270\n */\nexport function fixContinuity(dangle: number) {\n  dangle -= Math.round(dangle / 360) * 360\n  if (dangle > 270) return dangle - 360\n  if (dangle < -270) return dangle + 360\n  return dangle\n}\n","import DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { Vector2, WebKitGestureEvent } from '../types'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventValues,\n  getWheelEventValues,\n  getWebkitGestureEventValues,\n  getPointerIds,\n} from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, addEventIds, removeEventIds } from '../Controller'\n\nexport class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  readonly ingKey = 'pinching'\n  readonly stateKey = 'pinch'\n\n  onPinchStart = (event: React.TouchEvent | TouchEvent) => {\n    addEventIds(this.controller, event)\n\n    if (!this.enabled || this.state._active) return\n    // until we reach two fingers on the target don't react\n    if (this.controller.touchIds.size < 2) return\n    const _pointerIds = Array.from(this.controller.touchIds).slice(0, 2) as [number, number]\n\n    const { values, origin } = getTwoTouchesEventValues(event, _pointerIds, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerIds,\n      cancel: this.onCancel,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: React.TouchEvent | TouchEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin } = getTwoTouchesEventValues(event, this.state._pointerIds, this.transform)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...kinematics,\n      origin,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchEnd = (event: React.TouchEvent | TouchEvent): void => {\n    removeEventIds(this.controller, event)\n    const pointerIds = getPointerIds(event)\n\n    // if none of the lifted pointerIds is in the state pointerIds don't do anything\n    if (this.state._pointerIds.every(id => !pointerIds.includes(id))) return\n\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ _active: false, canceled: true })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault() // useless\n\n    const values = getWebkitGestureEventValues(event, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n      cancel: this.onCancel,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const values = getWebkitGestureEventValues(event, this.transform)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...kinematics,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n    this.fireGestureHandler()\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: React.WheelEvent | WheelEvent) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: React.WheelEvent | WheelEvent) => {\n    const [, delta_d] = getWheelEventValues(event, this.transform)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    const d = prev_d - delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [0, delta_d] as Vector2,\n    }\n  }\n\n  onWheel = (event: React.WheelEvent | WheelEvent): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: React.WheelEvent | WheelEvent): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (event.cancelable) event.preventDefault()\n    else if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      initial: this.state.values,\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.cancelable) event.preventDefault()\n\n    this.updateSharedState(getGenericEventData(event))\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (\n      this.controller.config.domTarget &&\n      !this.controller.supportsTouchEvents &&\n      this.controller.supportsGestureEvents\n    ) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart)\n      addBindings(bindings, 'onGestureChange', this.onGestureChange)\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd)\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart)\n      addBindings(bindings, 'onTouchMove', this.onPinchChange)\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd)\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd)\n      addBindings(bindings, 'onWheel', this.onWheel)\n    }\n  }\n}\n","import { UsePinchConfig, Handler, EventTypes } from '../types'\nimport { _buildPinchConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Pinch hook.\n *\n * @param handler - the function fired every time the pinch gesture updates\n * @param [config={}] - the config object including generic options and pinch options\n */\nexport function usePinch<K = EventTypes['pinch']>(handler: Handler<'pinch', K>, config: UsePinchConfig | {} = {}) {\n  RecognizersMap.set('pinch', PinchRecognizer)\n  const buildPinchConfig = useRef<any>()\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoize(_buildPinchConfig, isEqual)\n  }\n  return useRecognizers<UsePinchConfig>({ pinch: handler }, buildPinchConfig.current(config))\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  readonly ingKey = 'wheeling'\n  readonly stateKey = 'wheel'\n  debounced = true\n\n  handleEvent = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return\n    if (!this.enabled) return\n\n    this.setTimeout(this.onEnd)\n    this.updateSharedState(getGenericEventData(event))\n\n    const values = addV(getWheelEventValues(event, this.transform), this.state.values)\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event),\n        ...getGenericPayload(this, event, true),\n        initial: this.state.values,\n      })\n\n      const movement = this.getMovement(values)\n      const geometry = calculateAllGeometry(movement.delta!)\n\n      this.updateGestureState(movement)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const movement = this.getMovement(this.state.values)\n    this.updateGestureState(movement)\n    this.updateGestureState({ _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onWheel', this.handleEvent)\n  }\n}\n","import { UseWheelConfig, Handler, EventTypes } from '../types'\nimport { _buildWheelConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Wheel hook.\n *\n * @param handler - the function fired every time the wheel gesture updates\n * @param the config object including generic options and wheel options\n */\nexport function useWheel<K = EventTypes['wheel']>(handler: Handler<'wheel', K>, config: UseWheelConfig | {} = {}) {\n  RecognizersMap.set('wheel', WheelRecognizer)\n  const buildWheelConfig = useRef<any>()\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoize(_buildWheelConfig, isEqual)\n  }\n  return useRecognizers<UseWheelConfig>({ wheel: handler }, buildWheelConfig.current(config))\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  readonly ingKey = 'moving'\n  readonly stateKey = 'move'\n\n  debounced = true\n\n  onMove = (event: React.PointerEvent | PointerEvent): void => {\n    if (!this.enabled) return\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const values = this.state.values\n    this.updateGestureState(this.getMovement(values))\n    this.updateGestureState({ velocities: [0, 0], velocity: 0, _active: false })\n    this.fireGestureHandler()\n  }\n\n  hoverTransform = () => {\n    return this.controller.config.hover!.transform || this.controller.config.transform\n  }\n\n  onPointerEnter = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const values = getPointerEventValues(event, this.hoverTransform())\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...getGenericPayload(this, event, true),\n        args: this.args,\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n    if (!this.controller.config.hover!.enabled) return\n\n    const values = getPointerEventValues(event, this.hoverTransform())\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...getGenericPayload(this, event),\n      args: this.args,\n      values,\n      active: false,\n    }\n\n    this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n  }\n\n  addBindings(bindings: any): void {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove)\n    }\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter)\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave)\n    }\n  }\n}\n","import { UseMoveConfig, Handler, EventTypes } from '../types'\nimport { _buildMoveConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Move hook.\n *\n * @param handler - the function fired every time the move gesture updates\n * @param [config={}] - the config object including generic options and move options\n */\nexport function useMove<K = EventTypes['move']>(handler: Handler<'move', K>, config: UseMoveConfig | {} = {}) {\n  RecognizersMap.set('move', MoveRecognizer)\n  const buildMoveConfig = useRef<any>()\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoize(_buildMoveConfig, isEqual)\n  }\n  return useRecognizers<UseMoveConfig>({ move: handler }, buildMoveConfig.current(config))\n}\n","import { Handler, UseHoverConfig, EventTypes } from '../types'\nimport { _buildHoverConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Hover hook.\n *\n * @param handler - the function fired every time the hover gesture updates\n * @param [config={}] - the config object including generic options and hover options\n */\nexport function useHover<K = EventTypes['hover']>(handler: Handler<'hover', K>, config: UseHoverConfig | {} = {}) {\n  RecognizersMap.set('hover', MoveRecognizer)\n  const buildHoverConfig = useRef<any>()\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoize(_buildHoverConfig, isEqual)\n  }\n  return useRecognizers<UseHoverConfig>({ hover: handler }, buildHoverConfig.current(config))\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  readonly ingKey = 'scrolling'\n  readonly stateKey = 'scroll'\n  debounced = true\n\n  handleEvent = (event: React.UIEvent | UIEvent): void => {\n    if (!this.enabled) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const values = getScrollEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event),\n        ...getGenericPayload(this, event, true),\n        initial: this.state.values,\n      })\n\n      const movementDetection = this.getMovement(values)\n      const geometry = calculateAllGeometry(movementDetection.delta!)\n\n      this.updateGestureState(movementDetection)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.updateGestureState({ ...this.getMovement(this.state.values), _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onScroll', this.handleEvent)\n  }\n}\n","import { UseScrollConfig, Handler, EventTypes } from '../types'\nimport { _buildScrollConfig } from './buildConfig'\nimport useRecognizers from './useRecognizers'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport memoize from '../utils/memoize-one'\nimport isEqual from '../utils/react-fast-compare'\nimport { useRef } from 'react'\n\n/**\n * Scroll hook.\n *\n * @param handler - the function fired every time the scroll gesture updates\n * @param [config={}] - the config object including generic options and scroll options\n */\nexport function useScroll<K = EventTypes['scroll']>(handler: Handler<'scroll', K>, config: UseScrollConfig | {} = {}) {\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  const buildScrollConfig = useRef<any>()\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoize(_buildScrollConfig, isEqual)\n  }\n  return useRecognizers<UseScrollConfig>({ scroll: handler }, buildScrollConfig.current(config))\n}\n","import useRecognizers from './useRecognizers'\nimport { buildComplexConfig } from './buildConfig'\nimport {\n  InternalConfig,\n  InternalHandlers,\n  UserHandlers,\n  UseGestureConfig,\n  Handlers,\n  EventTypes,\n  AnyGestureEventTypes,\n} from '../types'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\n\nexport function wrapStart(fn: Function) {\n  return function (this: any, { first }: any) {\n    if (first) fn.apply(this, arguments)\n  }\n}\n\nexport function wrapEnd(fn: Function) {\n  return function (this: any, { last }: any) {\n    if (last) fn.apply(this, arguments)\n  }\n}\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/\n\nfunction sortHandlers(handlers: object) {\n  const native: any = {}\n  const handle: any = {}\n  const actions = new Set()\n\n  for (let key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch)\n      handle[key] = (handlers as any)[key]\n    } else {\n      native[key] = (handlers as any)[key]\n    }\n  }\n\n  return [handle, native, actions]\n}\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<T extends AnyGestureEventTypes = EventTypes>(\n  _handlers: Handlers<T>,\n  config: UseGestureConfig = {}\n) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(_handlers)\n\n  RecognizersMap.set('drag', DragRecognizer)\n  RecognizersMap.set('hover', MoveRecognizer)\n  RecognizersMap.set('move', MoveRecognizer)\n  RecognizersMap.set('pinch', PinchRecognizer)\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  RecognizersMap.set('wheel', WheelRecognizer)\n\n  const mergedConfig: InternalConfig = buildComplexConfig(config, actions)\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag')\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel')\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll')\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove')\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch')\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover\n\n  return useRecognizers<UseGestureConfig>(internalHandlers, mergedConfig, nativeHandlers)\n}\n\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\ntype HandlerKey = 'onDrag' | 'onPinch' | 'onWheel' | 'onMove' | 'onScroll' | 'onHover'\nfunction includeStartEndHandlers(handlers: Partial<UserHandlers>, handlerKey: HandlerKey) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n"]},"metadata":{},"sourceType":"module"}